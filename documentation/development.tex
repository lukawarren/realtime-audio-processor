\section{Development and Implementation}

Whilst the full source code is available in the appendix, the following section contains the most important parts of the code-base, highlighting the techniques used and technical solutions employed.

\subsection{Summary of techniques}
For handy reference, below is a table summarising the various techniques used in the codebase. \textbf{These are expanded upon in more detail below}.

{
	\renewcommand{\arraystretch}{1.5}
	\begin{table}[h!]
		\begin{center}
			\begin{tabularx}{1.0 \textwidth} {
					| >{\raggedright\arraybackslash}X 
					| >{\raggedright\arraybackslash}X
					| >{\raggedright\arraybackslash}X 
					|
				}
				\hline
				Source File & Technique & Purpose \\
				
				\hline
				include/data/atomic\_linked\_list.h & Thread-safe linked list (including linked list maintenance) from scratch and use of function callbacks & Provides data structure for inter-thread communication (see section 2.1) \\
				
				\hline
				include/data/tree.h and src/ui/file\_browser.cpp & Tree data structure and recursive navigation of filesystem & Used in file browsing to represent filesystem structure and allow the user to browse for audio files \\
				
				\hline
				src/data/merge-sort.cpp & Recursive merge-sort  algorithm implementation & To sort playlist files alphabetically \\
				
				\hline
				src/effects/fft.cpp & Cooley-Tukey Fast Fourier algorithm implementation & To aid in audio procession and visualisation \\
				
				\hline
				src/ui/audio\_visualiser.cpp & Uses FFT data & Renders audio visualisation \\
				
				\hline
				include/effects/audio\_effect.cpp & Polymorphic "audio effect" base class (inherited by children) - including use of hashmap & Manages common interface \\
				
				\hline
				include/effects/*property.h & Polymorphic "property" base class and associated children & Provides common interface for setting and getting properties of different types \\
				
				\hline
				src/effects/echo\_effect.cpp & Inheritance & Echo effect implementation \\
				
				\hline
				src/effects/equaliser\_effect.cpp &  Inheritance and use of Fourier algorithms & Audio equaliser implementation \\
				
				\hline
				src/effects/noise\_effect.cpp & Inheritance & Noise effect implementation \\
				
				\hline
				src/effects/volume\_effect.cpp & Inheritance & Volume effect implementation \\
				
				\hline
				Various files & Use of function callbacks & Used in many places, including preset creation and UI code \\
				
				\hline
				Various files & Error handling and user input sanitisation & Prevent program from experiencing crashes, security issues and undefined behaviour \\
				
				\hline
			\end{tabularx}
		\end{center}
	\end{table}
}

\pagebreak
\subsection{Atomic Linked List - \textit{include/data/atomic\_linked\_list.h}}
As discussed in section 2, the atomic linked list is a crucial component of the project.  It makes use of generics (C++ "templates") to allow it to store any arbitrary data type. 

The full code is listed below, followed by explanations below of the most critical parts.

\inputminted[linenos]{c++}{../include/data/atomic_linked_list.h}

\paragraph{Mutexes} Whenever a caller accesses the data structure, the mutex is first locked. The relevant operation is then performed, and the mutex is then unlocked, freeing the data structure for future use (in this thread or otherwise). This can be seen in the functions Add, Remove, ForEach, SwapWithNext and Reset.

\paragraph{Generics} To make the data structure as flexible as possible, it is written to store a generic type "T". Note that we cannot store a variable of type T directly, but must rather store a pointer to each "T", as some types may be too big to store on the stack.

\paragraph{Callbacks} The data structure provides a "ForEach" method which takes a callback as an argument. This callback is invoked upon every node in the linked list, in order to allow for arbitrary operations to be formed on each element. This is used in \textit{src/io/audio\_stream.cpp} and \textit{src/ui/effects\_window.cpp} to iterate over each node. For example, in the \textit{AudioStream} class:
\begin{minted}{c++}
effects->ForEach([&](AudioEffect* effect) {
	effect->ApplyEffect(packet);
});
\end{minted}

\paragraph{Linked List Maintenance}  The head and tail pointers of affected nodes are updated when adding and removing a node (in the \textit{Add} and \textit{Remove} subroutines respectively), as well as when swapping two nodes (\textit{SwapWithPrevious} and \textit{SwapWithNext}). The head and tail pointers are then used when iterating over the list (for example in \textit{ForEach}), and when calling the destructor.


\pagebreak
\subsection{File Browser and Associated Tree - \textit{include/data/tree.h} and \textit{src/ui/file\_browser.cpp }}

The filesystem is inherently recursive - that is, folders may contain files, but also other folders, which may themselves contain other files and folders. In order to elegantly model this, I decided to use a recursive tree. This resulted in the ability to represent, in memory, the exact nature of the filesystem, allowing for the GUI display below:

\begin{figure}[h]
	\includegraphics[width=13cm]{./file browser demo.png}
	\caption{Audio files are displayed in a graphical tree, backed by a tree in memory}
\end{figure}

\subsubsection{Tree data structure - \textit{include/data/tree.h}}
First, it was necessary to implement a tree data structure. Each node has a piece of data, followed by a list pointers to child nodes. Each child node may itself contain a piece of data, and a list of its own children.

As in C++ one must free explicit heap allocations manually,  recursion had to be used in the destructor. When the root node is destroyed, the following process occurs:
\begin{enumerate}
	\item C++ will call the destructor of the tree
	\item The tree iterates through all its children and calls their own respective destructors (line 16)
	\item This process repeats recursively until all children have deallocated their own children, and then finally themselves.
	\item Finally the root node deallocates itself.
\end{enumerate}
The full code is listed below.
\pagebreak
\inputminted[linenos]{c++}{../include/data/tree.h}

\pagebreak
\subsubsection{File Browser - \textit{src/ui/file\_browser.cpp}}
The file browser uses the tree data structure to store its files, and uses recursion to a greater extent. Below are the relevant parts of the code, followed by a description.

\inputminted[linenos, firstline=47, lastline=108]{c++}{../src/ui/file_browser.cpp}

\paragraph{The \textit{ScanDirectory} subroutine} This function is called on the root audio file directory (the user's Music folder). It creates a tree with a single node, containing the path to this directory. It then iterates through all the files and folders in the root directory. Files are added as children of the root node. If a directory is encountered instead, a tree for that directory is created by recursively calling \textit{ScanDIrectory} again, which is then added as a child to the existing tree. In this way, all files and folders contained within the root directory are added.  

\paragraph{The \textit{AddDirectory} subroutine} This subroutine is called once the tree containing all files and folders has already been created in \textit{ScanDirectory}. Each element is recursively added to a \textit{wxTreeListCtrl} (for the purposes of displaying the tree in the GUI) by first adding the directory itself, followed by the files contained within, then adding the sub-directories, which is done by recursively calling the function.

\pagebreak
\subsection{Merge Sort - \textit{src/data/merge\_sort.cpp}}
For ordering playlists alphabetically, a sorting  algorithm was needed. I decided to use a merge sort due to its low time complexity of \(O(N \log{N})\).
\inputminted[linenos]{c++}{../src/data/merge_sort.cpp}

\pagebreak
\subsection{Fourier Processing - \textit{src/effects/fft.cpp}}
This implements the pseudo-code produced in section 2.5, and hence uses recursion and the relevant Fourier maths, as well as linearising frequencies using the Bark scale. The relevant code is contained below.

\subsubsection{FFT Algorithm}
\inputminted[linenos, firstline=1, lastline=79]{c++}{../src/effects/fft.cpp}

\pagebreak
\subsubsection{Visualisation Algorithm}
As discussed in section 2.5, this transforms the data into a format easily plottable by the GUI code, and takes into account the non-linear scale of human hearing.
\inputminted[linenos, firstline=81, lastline=148]{c++}{../src/effects/fft.cpp}

\pagebreak
\subsubsection{Corresponding code to draw in GUI - \textit{src/ui/audio\_visualiser.cpp}}
Initially, results from the FFT were plotted straight to the screen. However, a key issue arose: audio changed so rapidly between frames that any visualisation was too flickery to be useful or readable.  To solve this, it was necessary to average the results of the FFT over multiple frames, so that changes in frequencies appeared more gradually. I also decided to colour the bars in the bar chart in accordance with their frequencies in order to increase the readability of the visualisation.

Each time a fixed buffer of audio is fed to the audio device (i.e. played to the speakers), the \textit{FeedAudio} subroutine is called, which performs a Fourier transform, adds it to the list of previous results for averaging, then triggers a GUI refresh.
\inputminted[linenos, firstline=15, lastline=44]{c++}{../src/ui/audio_visualiser.cpp}
\inputminted[linenos, firstline=67, lastline=165]{c++}{../src/ui/audio_visualiser.cpp}

\pagebreak
\subsection{Audio Effects and Properties}

\subsubsection{Base Audio Effect Class - \textit{include/effects/audio\_effect.h}}
The \textit{AudioEffect} base class has three key features:
\begin{enumerate}
	\item Provides a common interface for accessing "properties" (such as effect intensity). These properties are stored in a hashmap so that the names of the properties can be used as keys, and so that properties can be looked up with constant time complexity, which is important if any audio effects are added in the future that have a large number of properties to avoid wasting CPU cycles.
	\item Provides a common interface to identify the name of an effect in the GUI
	\item Provides a common interface to apply the effect to a "packet" of audio
\end{enumerate}
\inputminted[linenos]{c++}{../include/effects/audio_effect.h}

\pagebreak
\subsubsection{Property Base class - \textit{include/effects/property.h}}
\inputminted[linenos]{c++}{../include/effects/property.h}

\pagebreak
\subsubsection{IntegerProperty - \textit{include/effects/integer\_property.h}}
\inputminted[linenos]{c++}{../include/effects/integer_property.h}

\pagebreak
\subsubsection{FloatingPointProperty - \textit{include/effects/floating\_point\_property.h}}
\inputminted[linenos]{c++}{../include/effects/floating_point_property.h}


